---
title: "Follow-up Problem"
description: |
  Solution to Lambda Capital's follow-up problem
author:
  - name: Alexis Solis Cancino
    url: mailto:alexis.solisc@gmail.com
    # affiliation: ITAM
date: "`r Sys.Date()`"
output: 
  distill::distill_article:
    toc: true
    toc_float: true
    code_folding: true
    theme: "resources/theme.css"
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = T)
library(tidyverse)
library(lubridate)
```

# 1. Introduction

The task is to develop a backtest for a strategy that trades constituents of the S&P500 index from January 1st, 2010 through January 1st, 2020. Each day the strategy selects the 10 stocks with the highest [Price Rate of Change Indicator (ROC)](https://www.investopedia.com/terms/p/pricerateofchange.asp) and buys them on an equally-weighted basis.

It's important to verify that it only selects stocks that are part of the S&P500 index at each moment in time, as these change every quarter. A file should be generated with the values of the equity curve (Net Asset Value) over time and a file of weights or positions where you can see the stocks that were selected each day.


## 1.1 The S&P500 Index

The S&P500 index...

it rebalances every...

## 1.2 The Strategy


## 1.3 The Price Rate of Change (ROC)

https://www.investopedia.com/terms/p/pricerateofchange.asp

The ROC for 200 days would simply be:

\begin{equation}
\text{ROC}_{200d} = \left(\dfrac{P_t}{P_{t-200}}-1\right) \times 100
\end{equation}


# Data comes first

We were provided with two datasets: `closes.csv` and `constituents.csv`. We will begin by exploring the latter.

## Constituents Data

Apparently, we have daily closing data from `1997-12-31` through `2021-01-12` for `1,084` different securities.

We also read the `constituents.csv` data.

```{r}
constituents <- read_csv("data/constituents.csv", col_types = "dDcccccc") %>% 
  select(-1)

constituents %>% glimpse()
```


Let's use the `skimr` package to print a quick summary of missing and unique values of the data:

```{r}
constituents %>% 
  skimr::skim()
```

We see that the columns `contraticker`, `contraname` and `note` are the only columns that have missing values, which is both logical and acceptable.



```{r}
constituents %>% arrange(date)
```


```{r}
constituents %>% distinct(action)
```


```{r}
constituents %>% count(action)
```



`current` debe de corresponder a la muestra más reciente del S&P500. Corroboramos esto viendo los valores únicos para la fecha donde tenemos valores de `current`:

```{r}
constituents %>% filter(
  action == "current"
) %>% distinct(date)
```


A partir de cuándo empiezan y terminan los `historical`?

```{r}
constituents %>% 
  filter(
    action == "historical"
  ) %>%
  distinct(date) %>% 
  arrange(date)
```

Y los `added`?

```{r}
constituents %>% 
  filter(
    action == "added"
  ) %>%
  distinct(date) %>% 
  arrange(date)
```








Cuántos tickers únicos hay por `action`?

```{r}
constituents %>% count(action, ticker) %>% count(action)
```


A partir de cuándo empiezan y terminan los `historical`?

```{r}
constituents %>% 
  filter(
    action == "historical"
  ) %>%
  distinct(date) %>% 
  arrange(date)
```









Let's see the data for the first date `1957-03-04`:

```{r}
constituents %>% 
  filter(
    date == ymd("1957-03-04")
  )
```

It's clear that we don't have the initial S&P500 sample, so we will have to reverse engineer the constituents at each date. Let's start by the final date `2020-12-31`:

```{r}
constituents %>% 
  filter(date == ymd("2020-12-31"))
```


We see that we have sort-of-duplicated rows; we note that one `action` label corresponds to `historical` and the other one to `current`. Let's check that we actually have the same number per category:

```{r}
constituents %>% 
  filter(date == ymd("2020-12-31")) %>% 
  count(action)
```


We can focus on the `added` and `removed` actions, since it is these values the ones that hold most information regarding the S&P500 constituents. Since we're reverse engineering the index's constituents, we'll create a new variable (`reverse_action`) that tells us whether we have to add or remove that stock from the constituents. In case the `action` variable is `historical` or `current` we simply assign `no action`.

```{r}
constituent_actions <- constituents %>% 
  mutate(reverse_action = case_when(action == "added" ~ "remove",
                                    action == "removed" ~ "add",
                                    TRUE ~ "no action"))
```


```{r}
constituent_actions %>% 
  filter(reverse_action != "no action")
```

















## Data wrangling


```{r}
# Use read_csv() function to read the close data
close_tbl <- read_csv("data/closes.csv") %>% 
  select(-1)

close_tbl
```

We get the data into a long format (instead of the wide format with `1,085` columns).

```{r}
# close_long <- close_tbl %>% 
#   pivot_longer(cols = -date, names_to = "ticker", values_to = "close") %>% 
#   arrange(ticker, date)
# 
# close_long
```



```{r}
start_date <- ymd("2010-01-01")
end_date <- ymd("2020-01-01")
```



Delivery:

```{r}
tibble(
  date = ymd("2010-01-01"),
  nav = 1e6
)
```

```{r}
tibble(
  date = ymd("2010-01-01"),
  ticker = "AAPL",
  weight = .5
)
```

